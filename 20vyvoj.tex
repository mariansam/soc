\chapter{Vývoj implementace}

\section{Použité technologie}

Webová online multiplayer hra je implementovaná pomocí technologií, kterým se souhrnně říká T3 Stack. Podle oficiální dokumentace \parencite{t3stack} úkolem technologií T3 Stack je

\begin{enumerate}
    \item \B{Řešit problémy:} Neposkytovat všechny technologie, které jsou dostupné, ale poskytnout technologie, které jsou základem většiny webových aplikací a může být složité je nastavit manuálně.
    \item \B{\enquote{Krvácet} zodpovědně:} Poskytovat technologie, které jsou moderní a atraktivní, ale tak, aby v budoucnu netvořily problémy a případně se daly nahradit.
    \item \B{Typová bezpečnost není dobrovolná:} Znalost datových typů pomáhá programátorům s vývojem a bezpečným kódem, proto je v moderním vývoji naprosto nezbytná.
\end{enumerate}


Součástí T3 Stack je nástroj \M{create-t3-app}, který umožňuje vytvořit nový projekt, ve kterém jsou dané technologie předem nastavené.

Seznam technologií použitých:
\begin{itemize}
    \item \B{TypeScript:} Nadstavba nad programovacím jazykem JavaScript, která přidává typové anotace a jejich kontrolu. Tím umožňuje rychlejší a bezpečnější vývoj.
    \item \B{Next.js:} Moderní framework pro vytváření serverových částí webových  aplikací, slouží jako back-end pro React.
    \item \B{React:} Framework pro vytváření front-endových částí webových aplikací.
    \item \B{tRPC:} Knihovna pro bezpečnou a otypovanou komunikaci mezi front-endem (React) a back-endem (Next.js).
    \item \B{Prisma:} Knihovna pro komunikaci mezi back-endem (Next.js) a databází.
    \item \B{TailwindCSS:} Knihovna pro rychlé stylování webových aplikací.
\end{itemize}

Častou součástí této sady technologií též bývá NextAuth.js, které řeší přihlašování, registraci a správu uživatelů. Jelikož naše aplikace registraci uživatelů neumožňuje, není taková knihovna potřeba.

\section{Databáze}

Jako databáze k aplikaci byla zvolena PostgreSQL, jelikož se v dnešní době
jedná o jednu z nejpoužívanějších a nejoblíbenějších databází \cite{stackoverflow23}.

Schéma databáze je pouze jedna tabulka \M{GameSession} reprezentující jednu hru
mezi dvěma hráči. Vedle ní také enum \M{GridFieldState} reprezentující stav
jednoho hracího políčka (je prázdné, hrál na něj pouze první hráč, hrál na něj
pouze druhý hráč, hráli na něj oba hráči) a enum \M{GameState} reprezentující
stav hry (čeká se na druhého hráče, první hráč je na řadě, druhý hráč je na
řadě, první hráč vyhrál, druhý hráč vyhrál).

\begin{lstlisting}[language=Prisma,caption={Schéma databáze},label={fig:db-schema}]
enum GridFieldState {
    empty
    player1in
    player2in
    both
}

enum GameState {
    inviting
    player1plays
    player2plays
    player1won
    player2won
}

model GameSession {
    id          String      @id @default(cuid())
    createdAt   DateTime    @default(now())
    updatedAt   DateTime    @updatedAt
    slug        String      @unique
    player1     String?
    player2     String?
    visible     Boolean
    state       GameState   @default(inviting)
    lastPos     Int         @default(-1)
    grid        GridFieldState[]    @default([empty, empty, empty, empty, empty, empty, empty, empty, empty])
}
\end{lstlisting}

\section{Komunikace se serverem}

Komunikace mezi klientem (prohlížečem) a serverem je řešena pomocí tRPC a
WebSocketů. WebSocket umožňuje oboustrannou komunikaci mezi klientem a serverem
bez nutnosti pravidelného dotazování se serveru na změny \cite{mdn-ws}. tRPC
zajišťuje validaci a čtení dat (společně s knihovnou zod, v kódu zkracováno na
\M{z}) a poskytuje lepší vývojářský prožitek (developer experience) sdílením a
odvozováním typových anotací. Tedy když programátor na back-endu napíše funkci,
která bere jedno číslo a jeden text (string), i v kódu na front-endu mu
našeptávání v editoru bude doporučovat číslo a text a ukáže chybu, pokud by
programátor napsal argumenty k funkci špatně. Tím se odlišuje od tradičních
komunikačních technologiích jako je REST, u kterých je běžné předat vzdálené
funkci špatné argumenty, obzvláště pokud daný kód píše více vývojářů.

Příklad efektivního využití tRPC je vidět na back-endové funkci, která se stará
o zahrání tahu hráčem. Funkce přijímá tři argumenty: \M{slug} (specifický
string označující hru, kterou hráč hraje), \M{playerId} (specifický string
označující hráče), \M{buttonIndex} (číslo 0--8 označující herní políčko, do
kterého chce hráč zahrát). Všechny argumenty jsou automaticky přeloženy do
jejich správných datových typů, aby se s nimi dalo nadále pracovat. Pokud by
přišla nevalidní data (ať už chybou na front-endu nebo například od útočníka),
automaticky se vrátí error.

\begin{lstlisting}[language=JavaScript,caption={Funkce pro zahrání tahu},label={fig:be-make-move}]
makeMove: publicProcedure
    .input(z.object({
        slug: zodSlug(),
        playerId: z.string(),
        buttonIndex: z.number().min(0).max(8),
    }))
    .mutation(async ({ input: { slug, playerId, buttonIndex } }) => {
        console.log(`hrac ${playerId} ve hre ${slug} hraje na policko ${buttonIndex}`);
        // zbytek kodu pro zahrani tahu
\end{lstlisting}

Daná funkce se volá na front-endu po kliknutí na herní políčko se správnými
argumenty. Kdyby byl nějaký argument vynechán, byl předáván jako špatný datový
typ nebo nějaký přebýval, vyhodil by se error.

\begin{lstlisting}[language=JavaScript,caption={Volání funkce pro zahrání tahu},label={fig:fe-make-move}]
await makeMoveMutation.mutateAsync({
    slug,
    playerId,
    buttonIndex,
});
\end{lstlisting}

args
bagr

\begin{figure}[h]
    \centering
    \includegraphics[width=300px]{img/diagrams/create-new-game.pdf}
    \caption{XYz}
    \label{fig:create-new-game}
\end{figure}

penis

penis
